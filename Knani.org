#+TITLE: Mohamed Aziz Knani configuration file
#+AUTHOR: Mohamed Aziz Knani
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle init.el :results output silent
#+EXPORT_FILE_NAME: /home/mo/code/mohamed-aziz.github.io/emacs.html


* Introduction

  I like very much the idea of [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]], it appears that Org-mode in Emacs shines in doing this, the code here is tangled into an emacs lisp file and loaded by emacs, I also weave it into an html file and post it on my website.

  I suggest you start with a starter kit like bbastov's prelude not with mine since I make some decision you might not like.

  First backup your old configuration

  #+BEGIN_SRC sh :tangle no
    mv ~/.emacs.d ~/.emacs.d-back
  #+END_SRC

  Then can download my config doing:
   
  #+BEGIN_SRC sh :tangle no  
    git clone https://github.com/mohamed-aziz/.emacs.d-new.git ~/.emacs.d
  #+END_SRC
  
  Then install all the dependencies, for now I have no automated way of doing this.

  In the beginning this must be found in your init.el, this will just tangle =Knani.org=, reload =init.el= and byte compile it.

   #+BEGIN_SRC emacs-lisp :tangle no
     (require 'org)
     (org-babel-tangle-file (concat user-emacs-directory "Knani.org"))
     (load-file (concat user-emacs-directory "init.el"))
     (byte-compile-file (concat user-emacs-directory "init.el"))
   #+END_SRC
  
  If you are done with changes just re-tangle =Knani.org= using =C-c C-v t=.

* Initialize
** Personal Information
   #+BEGIN_SRC emacs-lisp
     (setq user-full-name "Mohamed Aziz Knani"
       user-mail-address "medazizknani@gmail.com")
   #+END_SRC
   
** Package sources

   Initialize package
   
    
   #+BEGIN_SRC emacs-lisp 
     (require 'package)
     (package-initialize)
   #+END_SRC

   
   If the system has gnutls use ssl.

   #+BEGIN_SRC emacs-lisp
     (let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                         (not (gnutls-available-p))))
            (url (concat (if no-ssl "http" "https") "://melpa.org/packages/")))
       (add-to-list 'package-archives (cons "melpa" url) t))

     (let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                         (not (gnutls-available-p))))
            (url (concat (if no-ssl "http" "https") "://orgmode.org/elpa/")))
       (add-to-list 'package-archives (cons "org" url) t))

   #+END_SRC

   from [[https://glyph.twistedmatrix.com/2015/11/editor-malware.html][glyph's blog]] 

   #+BEGIN_SRC emacs-lisp
     (setq tls-program "gnutls-cli")

     (let ((trustfile
            (replace-regexp-in-string
             "\\\\" "/"
             (replace-regexp-in-string
              "\n" ""
              (shell-command-to-string "python -m certifi")))))
       (setq tls-program
             (list
              (format "gnutls-cli%s --x509cafile %s -p %%p %%h"
                      (if (eq window-system 'w32) ".exe" "") trustfile))))

   #+END_SRC

   
** Load custom file

   Load custom settings

   #+BEGIN_SRC emacs-lisp 
     (setq custom-file (expand-file-name "custom.el" user-emacs-directory))

     (when (file-exists-p custom-file)
       (load custom-file))

   #+END_SRC

** Look and feel
   
   Define themes
   
    
   #+BEGIN_SRC emacs-lisp 
     (defconst dark-theme 'tao-yin)
     (defconst light-theme 'leuven)
   #+END_SRC
      
   
   #+BEGIN_SRC emacs-lisp 
     (tool-bar-mode   0)
     (menu-bar-mode   0)

     (when (> emacs-major-version 24)
       (scroll-bar-mode 0))

     (add-hook 'after-init-hook (lambda ()
				  (load-theme dark-theme)))

     ;; arabic font
     (when window-system
       (set-fontset-font "fontset-default" '(#x600 . #x6ff)
			 "Kawkab Mono"))


   #+END_SRC

   Set no-fringes mode

   #+BEGIN_SRC emacs-lisp
     (set-fringe-style '(0 . 0))
   #+END_SRC

** Add load paths

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path
                  (expand-file-name "lisp" user-emacs-directory))
     (add-to-list 'load-path
                  (expand-file-name "~/.local/usr/local/share/emacs/site-lisp/emms"))
     (add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")

   #+END_SRC

   
* Helm
  
  Enable helm

   
  #+BEGIN_SRC emacs-lisp
    (require 'helm)
    (helm-mode 1)
  #+END_SRC
  
  Add some keybindings for helm.
   
  #+BEGIN_SRC emacs-lisp  
    (global-set-key (kbd "M-x") #'helm-M-x)
    (global-set-key (kbd "C-x r b") #'helm-filtered-bookmarks)
    (global-set-key (kbd "C-x C-f") #'helm-find-files)
  #+END_SRC

  show kill ring keybinding
  
   
  #+BEGIN_SRC emacs-lisp 
    (global-set-key (kbd "C-c y") '(lambda ()
				     (interactive)
				     (helm-show-kill-ring)))
  #+END_SRC
  
* Dired

   
  #+BEGIN_SRC emacs-lisp 
    (require 'dired)
  #+END_SRC
  
** Keybindings

   #+BEGIN_SRC emacs-lisp  
     (define-key dired-mode-map "b" 'emms-add-dired)
     (define-key dired-mode-map (kbd "C-c f") 'find-name-dired)
     (define-key dired-mode-map (kbd "C-c o") 'crux-open-with)
   #+END_SRC


** Hide details
   
   This just hides details and just displays the files and directory names, this can be toggled using '('
   
   #+BEGIN_SRC emacs-lisp
     (add-hook 'dired-mode-hook '(lambda ()
                                 (dired-hide-details-mode)))

   #+END_SRC

** Switches
   
   Dired uses the ls program from GNU coreutils to get stuff, so you can do this

   #+BEGIN_SRC emacs-lisp
     (setq dired-listing-switches "-lah")
   #+END_SRC

   
** Download file

   An interactive function to download files from [[https://stackoverflow.com/questions/4448055/download-a-file-with-emacs-lisp][here]]

   #+BEGIN_SRC emacs-lisp  
     (require 'url)

     (defun download-file (&optional url download-dir download-name)
       (interactive)
       (let ((url (or url
                      (read-string "Enter download URL: "))))
         (let ((download-buffer (url-retrieve-synchronously url)))
           (with-current-buffer download-buffer
             ;; we may have to trim the http response
             (goto-char (point-min))
             (re-search-forward "^$" nil 'move)
             (forward-char)
             (delete-region (point-min) (point))
             (write-file (concat (or default-directory
                                     download-dir
                                     "~/Downloads"
                                     (or download-name
                                         (car (last (split-string url "/" t)))))))))))

   #+END_SRC


** Normalize filenames
   
   I have some functions to normalize filenames, this has some bugs though

    
   #+BEGIN_SRC emacs-lisp 
     (defun normalize-name (filename)
       "Replace space with underscore"
       (replace-regexp-in-string " " "_" filename))

     (defun dired-do-rename-file ()
       "Call dired-rename-file"
       (let ((file (file-name-base (dired-get-filename nil t))))
         (print file)
         (dired-rename-file file (normalize-name file) nil)))

     (defun dired-normalize-name (&optional arg)
       "Normalize files from dired"
       (interactive "P")
       (dired-map-over-marks-check (function dired-do-rename-file) arg 'normalize t)
       (revert-buffer))

   #+END_SRC

   
** Open with xdg-open
   
   This just lets me open files (or directories) with their default applications, it doesn't support windows though since I don't think that it has a facility to open files like that.
   
   This is stolen from bbastov crux package

   #+BEGIN_SRC emacs-lisp
     (defun crux-open-with (arg)
       "Open visited file in default external program.
     When in dired mode, open file under the cursor.
     With a prefix ARG always prompt for command to use."
       (interactive "P")
       (let* ((current-file-name
               (if (eq major-mode 'dired-mode)
                   (dired-get-file-for-visit)
                 buffer-file-name))
              (open (pcase system-type
                      (`darwin "open")
                      ((or `gnu `gnu/linux `gnu/kfreebsd) "xdg-open")))
              (program (if (or arg (not open))
                           (read-shell-command "Open current file with: ")
                         open)))
         (call-process program nil 0 nil current-file-name)))

   #+END_SRC


** Dired async

   I like using dired async

   #+BEGIN_SRC emacs-lisp
     (require 'dired-async)
     (dired-async-mode 1)
   #+END_SRC


** Dired subtree
   
   This requires dired-hacks-utils

    
   #+BEGIN_SRC emacs-lisp  
     (require 'dired-subtree)

     (define-key dired-mode-map "i" 'dired-subtree-insert)
     (define-key dired-mode-map ";" 'dired-subtree-remove)
   #+END_SRC

** Some other stuff
   
   Some other stuff like dwim and dired-fixups

    
   #+BEGIN_SRC emacs-lisp  
     (require 'dired-fixups)
     (setq dired-dwim-target t)

   #+END_SRC
* ERC

  ERC is my default IRC client

   
  #+BEGIN_SRC emacs-lisp
    (require 'erc)
    (require 'erc-log)

    (setq erc-log-channels-directory "~/.erc/logs/")
    (erc-truncate-mode +1)
    (erc-spelling-mode 1)
    (setq erc-server-coding-system '(utf-8 . utf-8))
    (setq erc-autojoin-channels-alist '(("freenode.net" . ("#python"
							       "#python-eve"
							       "#pocoo"
							       "#emacs"
							       "#gnu"
							       "#django"
							       "#crypto"
							       "##programming"))
					("oftc.net" . ("#suckless"
							   "#debian"))))
  #+END_SRC
** Hide from mode-line

   #+BEGIN_SRC emacs-lisp
     (erc-track-mode nil)
     (setq  erc-track-position-in-mode-line nil
	    erc-mode-line-format "")
   #+END_SRC

* Eshell
  
** Background makes
   from emacswiki

   #+BEGIN_SRC emacs-lisp
     (defun eshell/ec (&rest args)
       "Use `compile' to do background makes."
       (if (eshell-interactive-output-p)
	   (let ((compilation-process-setup-function
		  (list 'lambda nil
			(list 'setq 'process-environment
			      (list 'quote (eshell-copy-environment))))))
	     (compile (eshell-flatten-and-stringify args))
	     (pop-to-buffer compilation-last-buffer))
	 (throw 'eshell-replace-command
		(let ((l (eshell-stringify-list (eshell-flatten-list args))))
		  (eshell-parse-command (car l) (cdr l))))))
     (put 'eshell/ec 'eshell-no-numeric-conversions t)
   #+END_SRC
** Pyvenv integration

   Integration of pyvenv within Eshell

   #+BEGIN_SRC emacs-lisp
     (with-eval-after-load 'eshell
       (defvar eshell-path-env)
       (dolist (hook '(pyvenv-post-activate-hooks pyvenv-post-deactivate-hooks))
         (add-hook hook                  ; eshell
                   (lambda ()
                     (let ((path-env (mapconcat (lambda (x) (or x "."))
                                                exec-path
                                                path-separator)))
                       (setq-default eshell-path-env path-env)
                       (dolist (buffer (buffer-list))
                         (with-current-buffer buffer
                           (and (derived-mode-p 'eshell-mode)
                                (setq eshell-path-env path-env)))))))))

   #+END_SRC
* Email
  
  I use mu4e for Mail
  
   
  #+BEGIN_SRC emacs-lisp  
    (require 'mu4e)
  #+END_SRC

  set the mail directory

   
  #+BEGIN_SRC emacs-lisp  
  (setq mu4e-maildir (expand-file-name "~/Maildir"))
  #+END_SRC

  load file with email configuration
  
   
  #+BEGIN_SRC emacs-lisp  
    (load-file (expand-file-name "~/email.el"))
  #+END_SRC
  
  set the user email address

   
  #+BEGIN_SRC emacs-lisp
    (setq mu4e-user-mail-address-list
          (mapcar (lambda (account) (cadr (assq 'user-mail-address account)))
                  my/mu4e-account-alist))
  #+END_SRC


   
  #+BEGIN_SRC emacs-lisp 
    (setq mu4e-sent-messages-behavior 'delete)
  #+END_SRC  

  update mail using offlineimap
  
   
  #+BEGIN_SRC emacs-lisp  
    (setq mu4e-get-mail-command "offlineimap")

  #+END_SRC

  
  send mail using SMTP, anyways who the fuck uses IMAP to send mails.

  Here authinfo.gpg is encrpyted using GNUpg, just make sure you don't use symmetric encrpytion so that you don't enter the password every single time (GNUpg caches the passwords using gpg-agent for some time I think)

   
  #+BEGIN_SRC emacs-lisp  
    (require 'smtpmail)

    (setq message-send-mail-function 'smtpmail-send-it
	  starttls-use-gnutls t
	  smtpmail-auth-credentials (expand-file-name "~/.authinfo.gpg")
	  smtpmail-debug-info t)
  #+END_SRC

** Epa integration
  
    
   #+BEGIN_SRC emacs-lisp  
     (add-hook 'message-mode-hook (lambda ()
			       (epa-mail-mode)))

     (add-hook 'mu4e-view-mode-hook (lambda ()
				      (epa-mail-mode)))

     (add-hook 'mu4e-compose-mode-hook (lambda ()
					 (epa-mail-mode)))
   #+END_SRC

** Offlineimap configuration
   
   This is not Emacs specific but I just wanted to throw it here

   here is my .offlineimaprc

    
   #+BEGIN_SRC c :tangle no
       [general]
     accounts = Gmail
     maxconnections = 3
     maxsyncaccounts = 1
     pythonfile = ~/.offlineimap.py

     [Account Gmail]
     localrepository = Local
     remoterepository = Remote

     [Repository Local]
     type = Maildir
     localfolders = ~/Maildir

     [Repository Remote]
     type = Gmail
     remoteuser = medazizknani@gmail.com
     remotepasseval = get_password_emacs("imap.gmail.com", "medazizknani@gmail.com", "993")
     realdelete = no

     folderfilter = lambda foldername: foldername not in ['[Gmail]/Spam', '[Gmail].Tous les messages', '[Gmail].Suivis', '[Gmail]/Important']

     remotepass = password

     holdconnectionopen = true
     keepalive = 60
     sslcacertfile = /etc/ssl/certs/ca-certificates.crt


     [Account MAKCock]
     localrepository = LocalCock
     remoterepository = RemoteCock

     [Repository LocalCock]
     type = Maildir
     localfolders = ~/Maildir/Cock

     [Repository RemoteCock]
     type = IMAP
     remotehost = mail.cock.li
     remoteuser = mak@cock.li
     remotepasseval = get_password_emacs("mail.cock.li", "mak@cock.li", "993")
     realdelete = no
     remotepass = password
     holdconnectionopen = true
     keepalive = 60
     sslcacertfile = /etc/ssl/certs/ca-certificates.crt

   #+END_SRC

   as for the =get_password_emacs= function here it is

    
   #+BEGIN_SRC python :tangle no
     import re, os

     def get_password_emacs(machine, login, port):
         s = "^machine %s login %s port %s password ([^ ]*)$" % (machine, login, port)
         p = re.compile(s)
         authinfo = os.popen("gpg -q --no-tty -d ~/.authinfo.gpg").read()
         for entry in authinfo.splitlines():
             # return on first match
             if p.search(entry):
                 return p.search(entry).group(1)
             else:
                 continue

   #+END_SRC

** Async smtp send function

    
   #+BEGIN_SRC emacs-lisp  
     (require 'smtpmail-async)

     (setq send-mail-function 'async-smtpmail-send-it
	   message-send-mail-function 'async-smtpmail-send-it)
   #+END_SRC

** Disable duplicates

   This happens with gmail and offlineimap

   #+BEGIN_SRC emacs-lisp
     (setq mu4e-headers-skip-duplicates t)
   #+END_SRC

** Multiple mail
   
   I use multiple mail accounts

   the code is [[https://www.djcbsoftware.nl/code/mu/mu4e/Multiple-accounts.html][apdated from here]] it takes advantage of mu4e contexts

   sets the current account and the last read account

    
   #+BEGIN_SRC emacs-lisp  
     (defvar my/mu4e-last-read-account "")
     (defvar my/mu4e-current-account nil)
   #+END_SRC

   the function that sets accounts
   

    
   #+BEGIN_SRC emacs-lisp  
     (defun my/mu4e-set-account ()
       "Set the account for composing a message."
       (interactive)
       (let* ((account
               (if mu4e-compose-parent-message
                   (let ((maildir (mu4e-message-field mu4e-compose-parent-message :maildir)))
                     (string-match "/\\(.*?\\)/" maildir)
                     (match-string 1 maildir))
                 (completing-read (format "Compose with account: (%s) "
                                          (mapconcat #'(lambda (var) (if (string= (car var) my/mu4e-last-read-account)
                                                                    (format "[%s]" (car var))
                                                                  (car var)))
                                                     my/mu4e-account-alist "/"))
                                  (mapcar #'(lambda (var) (car var)) my/mu4e-account-alist)
                                  nil t nil nil (caar my/mu4e-account-alist))))
              (account-vars (cdr (assoc account my/mu4e-account-alist))))
         (progn
           (setq my/mu4e-last-read-account account)
           (setq my/mu4e-current-account account-vars)
           (if account-vars
               (mapc #'(lambda (var)
                         (set (car var) (cadr var)))
                     account-vars)
             (error "No email account found")))))
   #+END_SRC
   

   This is function insert the signature, I'm not sure why this doesn't happen by default, this is a fast hack, clearly it needs more debugging

    
   #+BEGIN_SRC emacs-lisp  
     (defun my/mu4e-execute-account-vars ()
       "docstring"
       (when my/mu4e-current-account
         (progn
           (mapc #'(lambda (var)
                     (set (car var) (cadr var)))
                 my/mu4e-current-account))
         (when (string= "*draft*"  (buffer-name))
           (when message-signature
             (message-insert-signature)))))
     (add-hook 'mu4e-compose-mode-hook 'my/mu4e-execute-account-vars)
   #+END_SRC


   set the keybinding

    
   #+BEGIN_SRC emacs-lisp  
     (global-set-key (kbd "C-x c") 'my/mu4e-set-account)
   #+END_SRC
   
* Perspective

  I was a heavy GNU screen user, and before that Tmux, well not anymore since I found that I can do that inside Emacs

   
  #+BEGIN_SRC emacs-lisp  
    (require 'perspective)

    (setq persp-initial-frame-name "dev")
    (persp-mode t)
  #+END_SRC

  
** Perspectives

   This is my perspectives (or virtual desktops)

    
   #+BEGIN_SRC emacs-lisp  
     ;; (persp-switch "irc")
     (with-perspective "email"
       (mu4e)
       ;; the easy way, feasible also with emacs-async
       (sleep-for 1))

     (with-perspective "files"
       (dired "~/"))

     (with-perspective "org"
       (org-agenda-list)
       (sleep-for 1)
       (delete-other-windows)
       (switch-to-buffer "*Org Agenda*"))

     (with-perspective "eshell"
       (eshell))

     (require 'proced)
     (with-perspective "proced"
       (proced)
       (delete-other-windows)
       (switch-to-buffer "*Proced*"))
   #+END_SRC
   
** Show only current perspective

    
   #+BEGIN_SRC emacs-lisp  
     (defun persp-update-modestring ()
       "Update `persp-modestring' to reflect the current perspectives.
     Has no effect when `persp-show-modestring' is nil."
       (when persp-show-modestring
	 (let ((open (list (nth 0 persp-modestring-dividers)))
	       (close (list (nth 1 persp-modestring-dividers)))
	       (sep (nth 2 persp-modestring-dividers)))
	   (if persp-curr
	       (setq persp-modestring
		     (append open (list (persp-format-name (persp-name persp-curr)))
			     close))
	     (setq persp-modestring nil)))))
   #+END_SRC

* Music

  I use EMMS for music, I also have emms-player-mpv to play the thing inside mpv.

   
  #+BEGIN_SRC emacs-lisp
    (require 'emms-setup)
    (emms-standard)
    (emms-default-players)
    ;; fallback to mplayer
    (define-emms-simple-player mplayer '(file url)
      (regexp-opt '(".ogg" ".mp3" ".wav" ".mpg" ".mpeg" ".wmv" ".wma" ".webm"
		    ".mov" ".avi" ".divx" ".ogm" ".asf" ".mkv" "http://" "mms://"
		    ".aiff"
		    ".rm" ".rmvb" ".mp4" ".flac" ".vob" ".m4a" ".flv" ".ogv" ".pls" ".opus"))
      "mplayer" "-slave" "-quiet" "-really-quiet" "-fullscreen")

    (define-emms-simple-player mpv '(file url streamlist playlist)
      (concat "\\`\\(http\\|mms\\|tcp\\)://\\|"
	      (emms-player-simple-regexp
	       "ogg" "mp3" "wav" "mpg" "mpeg" "wmv" "wma"
	       "mov" "avi" "divx" "ogm" "ogv" "asf" "mkv"
	       "rm" "rmvb" "mp4" "flac" "vob" "m4a" "ape"
	       "flv" "webm" "m4b" "m4p" "m4v" "m4r" "3gp"
	       "aac" "aiff"))
      "mpv" "--quiet" "--really-quiet")

    (require 'emms-player-mpv)
    (add-to-list 'emms-player-list 'emms-player-mpv)

    (require 'emms-info-libtag)
    (setq emms-info-functions '(emms-info-libtag))
    ;;; below is a nice key command for toggling the music browser
    (autoload 'emms-smart-browse "emms-browser.el" "Browse with EMMS" t)

    (global-set-key [(f7)] 'emms-smart-browse)

    (setq emms-source-file-default-directory "~/Music/")
  #+END_SRC

  I also have this in my mpv configuration

     
     #+BEGIN_SRC sh :tangle no
       audio-display=no
     #+END_SRC

  
  If someone has an elegant function to resize covers and display it inside emms-browser, I would be very happy if you email it to me.

** Perspective

    
   #+BEGIN_SRC emacs-lisp  
     (with-perspective "music"
       (emms-smart-browse))
   #+END_SRC
** Covers
   
   This piece of code doesn't always work, also I need a way around imagemagick to resize all covers

    
   #+BEGIN_SRC emacs-lisp
     (defun my-emms-covers (dir type)
       "Choose album cover in DIR deppending on TYPE.
     Small cover should be less than 80000 bytes.
     Medium - less than 120000 bytes."
       (let* ((pics (directory-files-and-attributes
		     dir t "\\.\\(jpe?g\\|png\\|gif\\|bmp\\)$" t))
	      (pic (car pics))
	      (pic-size (nth 8 pic)))
	 (let (temp)
	   (cond
	    ((eq type 'small)
	     (while (setq temp (cadr pics))
	       (let ((temp-size (nth 8 temp)))
		 (if (< temp-size pic-size)
		     (setq pic temp
			   pic-size temp-size)))
	       (setq pics (cdr pics)))
	     (if (<= (or pic-size 80001) 80000)
		 (car pic)))
	    ((eq type 'medium)
	     (if (and pic (setq temp (cadr pics)))
		 (progn
		   (setq pics (cdr pics))
		   (let ((temp-size (nth 8 temp)))
		     (let ((small temp)
			   (small-size temp-size))
		       (if (< pic-size small-size)
			   (setq small pic
				 small-size pic-size
				 pic temp
				 pic-size temp-size))
		       (while (setq temp (cadr pics))
			 (setq temp-size (nth 8 temp))
			 (cond
			  ((< temp-size small-size)
			   (setq pic small
				 pic-size small-size
				 small temp
				 small-size temp-size))
			  ((< temp-size pic-size)
			   (setq pic temp
				 pic-size temp-size)))
			 (setq pics (cdr pics)))
		       (car (if (<= pic-size 120000) pic
			      small)))))
	       (car pic)))
	    ((eq type 'large)
	     (while (setq temp (cadr pics))
	       (let ((temp-size (nth 8 temp)))
		 (if (> temp-size pic-size)
		     (setq pic temp
			   pic-size temp-size)))
	       (setq pics (cdr pics)))
	     (car pic))))))


     (add-hook 'emms-playlist-mode-hook
	       (lambda ()
		 (setq emms-browser-covers 'my-emms-covers)))
   #+END_SRC
* Org

   
  #+BEGIN_SRC emacs-lisp
    (require 'org)
  #+END_SRC

  What to record when a task is marked done

   
  #+BEGIN_SRC emacs-lisp
    (setq org-log-done 'time)
  #+END_SRC
  
  For better viewing math equations

   
  #+BEGIN_SRC emacs-lisp
    (setq org-format-latex-options (plist-put org-format-latex-options :scale 1.7))
  #+END_SRC

  setting program for rendering latex fragments

  #+BEGIN_SRC emacs-lisp
    (setq org-preview-latex-default-process 'dvisvgm)
  #+END_SRC

  For easier math symbols input for latex

   
** Org-tangle disable confirmation
   #+BEGIN_SRC emacs-lisp
     (setq  org-confirm-babel-evaluate nil)
   #+END_SRC
** Some eye candy stuff

   What is olivetti-mode?

   
  #+BEGIN_SRC emacs-lisp
    (add-hook 'org-mode-hook '(lambda ()
                                (setq left-margin-width 5)
                                (setq right-margin-width 5)
                                (visual-line-mode)
                                (flyspell-mode)))
  #+END_SRC

  This is my agenda files
  
  Org personal files:

  #+BEGIN_SRC emacs-lisp
    (load-file (expand-file-name "~/orgfiles.el"))
  #+END_SRC

** Keybindings

   
  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-c a") 'org-agenda)
    (define-key org-mode-map (kbd "M-RET") 'org-insert-heading)
    (define-key global-map "\C-cc" 'org-capture)
    (add-hook 'org-shiftup-final-hook 'windmove-up)
    (add-hook 'org-shiftleft-final-hook 'windmove-left)
    (add-hook 'org-shiftdown-final-hook 'windmove-down)
    (add-hook 'org-shiftright-final-hook 'windmove-right)
  #+END_SRC

  
**  org-trello sutff
   
    
   #+BEGIN_SRC emacs-lisp
     (require 'org-trello)

     (setq org-trello-files
	   `(,(concat org-directory "/work.org")))
   #+END_SRC
   
** C/C++
   
   For working with C/C++/D source code

    
   #+BEGIN_SRC emacs-lisp  
     (org-babel-do-load-languages
      'org-babel-load-languages '((C . t)
				  (shell . t)
				  (python . t)))
   #+END_SRC

** Hylang

    
   #+BEGIN_SRC emacs-lisp  
     (require 'ob-hy)
     (org-babel-do-load-languages
      'org-babel-load-languages '((hy . t)))
   #+END_SRC
** Shoot and insert
   
   Utility function I use to take a screenshot of a dosbox window and then inserting the image in a org-mode buffer.
   
    Screenshot
   #+BEGIN_SRC emacs-lisp 
     (defun insert-shot ()
       (interactive)
       (let*
           ((filename (concat (format "%04x" (random (expt 16 4))) ".png" )))
         ;; change to window; take shot; and insert it
         (shell-command (concat "wmctrl -a WINXP && import -window $(xdotool getactivewindow) " filename))
         ;; return to emacs
         (shell-command "wmctrl -a Emacs")
         ;; insert image to org file
         (insert (format "
     ,#+CAPTION: caption
     ,#+LABEL: fig:label
     ,#+ATTR_LATEX: :float

     [[file:%s]]" filename))))

     (define-key org-mode-map (kbd "<f8>") 'insert-shot)
   #+END_SRC
   
** Org crypt

   auto crypt org files using EasyPG

    
   #+BEGIN_SRC emacs-lisp 
     (require 'org-crypt)
     (org-crypt-use-before-save-magic)
   #+END_SRC

** Org capture

    
   #+BEGIN_SRC emacs-lisp 
     (setq org-default-notes-file (expand-file-name "~/notes.org"))
   #+END_SRC
   
   Org contacts 
   
   mu4e, get email form name

    
   #+BEGIN_SRC emacs-lisp  
     (defun org-contacts-mu4e-get-name-email ()
       "Get name and email address from Gnus message."
       (if (gnus-alive-p)
	   (gnus-with-article-headers
	     (mail-extract-address-components
	      (or (mail-fetch-field "From") "")))))
   #+END_SRC

   Org contacts phone number template:

    
   #+BEGIN_SRC emacs-lisp  
     (defun org-contacts-template-phone (&optional return-value)
       "Try to return the contact phne for a template.
     If not found return RETURN-VALUE or something that would ask the user."
       (or (cadr (org-contacts-gnus-get-name-email))
	   return-value
	   (concat "%^{PHONE}p")))
   #+END_SRC

   org-capture contacts template:

    
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'org-capture-templates
		  `("c" "Contacts" entry (file ,(concat org-directory "/people.org"))
		    "* %(org-contacts-template-name)
     :PROPERTIES:
     :EMAIL: %(org-contacts-template-email)
     :PHONE: %(org-contacts-template-phone)
     :END:"))
   #+END_SRC


   Capture web content

    
   #+BEGIN_SRC emacs-lisp  
     (add-to-list 'org-capture-templates
		  `("w" "Web site" entry
		    (file ,(concat org-directory "/websites.org"))
		    "* %a %^g \n\ncaptured on: %U \n\n%?\n\n%:initial"))
   #+END_SRC

   todo template

    
   #+BEGIN_SRC emacs-lisp  
     (add-to-list 'org-capture-templates
		  `("t" "Todo" entry (file ,(concat org-directory "/tasks.org"))
		    "* TODO %?\n  %i\n  %a"))
   #+END_SRC


   Capture web bookmarks

    
   #+BEGIN_SRC emacs-lisp  
     (add-to-list 'org-capture-templates
		 `("b" "Web site bookmark" entry
		    (file ,(concat org-directory "/bookmarks.org"))
		    "* %a %^g\n\n  %?\n  captured on: %U\n\n%:initial"))
   #+END_SRC


   Capture code snippets and computer stuff

   #+BEGIN_SRC emacs-lisp  
     (add-to-list 'org-capture-templates
		  `("T" "Tip" entry (file ,(concat org-directory "/tip.org"))
		    "* %? %^g\n  #+BEGIN_SRC\n%x\n  #+END_SRC\n  %a\n  captured on: %U\n\n"))
   #+END_SRC


*** Org protocol capture
    Org protocol stuff


     
    #+BEGIN_SRC emacs-lisp 
      (server-start)
      (require 'org-protocol)
      (require 'org-protocol-capture-html)
    #+END_SRC

    template

     
    #+BEGIN_SRC emacs-lisp

      (add-to-list 'org-capture-templates 
		   `("p" "Protocol" entry (file+headline ,(concat org-directory "protocol.org") "Inbox")
		     "* %^{Title}\nSource: %u, %c\n #+BEGIN_QUOTE\n%i\n#+END_QUOTE\n\n\n%?"))

      (add-to-list 'org-capture-templates 
		   `("L" "Protocol Link" entry (file+headline ,(concat org-directory "protocol.org") "Inbox")
					     "* %? [[%:link][%:description]] \nCaptured On: %U"))
    #+END_SRC
** Org contact
   
   Set org contact files

    
   #+BEGIN_SRC emacs-lisp 
     (require 'org-contacts)
     (setq  org-contacts-files `(,(concat org-directory "/people.org")))
   #+END_SRC
   org-contacts-files

   set org 

** Latex export code stuff
    
   #+BEGIN_SRC emacs-lisp 
     (setq ;; org-latex-listings 'minted
           org-latex-packages-alist '(("" "minted"))
           org-src-fontify-natively t
           org-latex-pdf-process
           '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
             "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
   #+END_SRC
   
** Custom faces

    
   #+BEGIN_SRC emacs-lisp 
     (custom-set-faces
      '(org-block ((t (:height 1.3)))))
   #+END_SRC
* Presentations

  zpresent is what I use for presentations

   
  #+BEGIN_SRC emacs-lisp  
    (require 'ox-reveal)

    (setq org-reveal-root "file:///home/mo/code/reveal.js")
  #+END_SRC
  
  This needs xwidget support
   
  #+BEGIN_SRC emacs-lisp  
    (require 'bodil-revealjs)
  #+END_SRC

* Development

** Javascript

    
   #+BEGIN_SRC emacs-lisp 
     (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
   #+END_SRC

   Allow not ending with semi-colon 

    
   #+BEGIN_SRC emacs-lisp 
     (setq js2-strict-missing-semi-warning nil)
   #+END_SRC
   
** Common Lisp
   set inferior lisp program.

    
   #+BEGIN_SRC emacs-lisp  
     (setq inferior-lisp-program "sbcl"
	   slime-contribs '(slime-fancy))
   #+END_SRC
   
   CL hook:

   #+BEGIN_SRC emacs-lisp
     (add-hook 'lisp-mode-hook (lambda ()
				(paredit-mode)))
   #+END_SRC
** Python
   
   I'm a heavy python user, but my config is less than 2 instructions, which is great since elpy offers tons of things out of the box

    
   #+BEGIN_SRC emacs-lisp  
     (elpy-enable)

     (setenv "WORKON_HOME" "/home/mo/vEnvs/")
   #+END_SRC
** C   
*** Cflow
    #+BEGIN_SRC emacs-lisp
      (autoload 'cflow-mode "cflow-mode")
      (setq auto-mode-alist (append auto-mode-alist
				    '(("\\.cflow$" . cflow-mode))))
    #+END_SRC
** C++

   Setting compile command and recompile key

    
   #+BEGIN_SRC emacs-lisp        
     (add-hook 'c++-mode-hook (lambda ()
                               (when (buffer-file-name)
                                 (setq compile-command (concat "g++ -g " (buffer-file-name))))))
     (define-key c++-mode-map (kbd "C-c C-r") 'recompile)
   #+END_SRC

** Web dev

   I mainly do vuejs, I use ES6, but I use js-mode not js2-mode since MMM-mode doesn't seem to support it.

    
   #+BEGIN_SRC emacs-lisp  
     (require 'vue-mode)
     (require 'emmet-mode)
     (require 'web-mode)

     (setq js-indent-level 2)

     (add-hook 'vue-mode-hook 'emmet-mode)
     (add-hook 'css-mode-hook 'emmet-mode)
     (add-hook 'web-mode-hook 'emmet-mode)
   #+END_SRC

** Elisp
   
   Enable show-paren and paredit for Emacs lisp code
   
    
   #+BEGIN_SRC emacs-lisp 
     (add-hook 'emacs-lisp-mode-hook (lambda ()
                                       (show-paren-mode 1)
                                       (paredit-mode 1)))
   #+END_SRC

** Hylang
   
    
   #+BEGIN_SRC emacs-lisp 
     (require 'hy-mode)
     (add-hook 'hy-mode-hook (lambda ()
                               (show-paren-mode 1)
                               (paredit-mode 1)
                               (set (make-local-variable 'company-backends) '(company-hy))))
   #+END_SRC
   
* Pomodoro

  I use the pomodoro technique when working on writing or programming projects

   
  #+BEGIN_SRC emacs-lisp  
    (require 'pomodoro) 
    (pomodoro-add-to-mode-line)
  #+END_SRC

* Prettify symbols

  Some stuff to prettify

** Prog-mode
    
   #+BEGIN_SRC emacs-lisp  
     (global-prettify-symbols-mode 1)
     (add-hook 'prog-mode-hook
               (lambda ()
                 (push '("!="      . ?≠) prettify-symbols-alist)
                 (push '("<="      . ?≤) prettify-symbols-alist)
                 (push '(">="      . ?≥) prettify-symbols-alist)
                 (push '("alpha"   . ?α) prettify-symbols-alist)
                 (push '("beta"    . ?β) prettify-symbols-alist)
                 (push '("gamma"   . ?γ) prettify-symbols-alist)
                 (push '("delta"   . ?Δ) prettify-symbols-alist)
                 (push '("epsilon" . ?ε) prettify-symbols-alist)
                 (push '("theta"   . ?θ) prettify-symbols-alist)
                 (push '("pi"      . ?π) prettify-symbols-alist)
                 (push '("sqrt"    . ?√) prettify-symbols-alist)))
   #+END_SRC

** Python-mode
   
    
   #+BEGIN_SRC emacs-lisp  
     (add-hook 'python-mode-hook
               (lambda ()
                 (push '("def" . ?ƒ) prettify-symbols-alist)
                 (push '("sum" . ?∑) prettify-symbols-alist)
                 (push '("**2" . ?²) prettify-symbols-alist)
                 (push '("**3" . ?³) prettify-symbols-alist)))

   #+END_SRC

** Unprettify at point

    
   #+BEGIN_SRC emacs-lisp
     (setq prettify-symbols-unprettify-at-point t)
   #+END_SRC
* Projectile
  
   
  #+BEGIN_SRC emacs-lisp
    (require 'projectile)

    (projectile-mode 1)    
  #+END_SRC

  use grep only on files tracked by git

   
  #+BEGIN_SRC emacs-lisp
    (setq projectile-use-git-grep 1)

  #+END_SRC

  enable helm-projectile

   
  #+BEGIN_SRC emacs-lisp  
    (require 'helm-projectile)
    (helm-projectile-on)
  #+END_SRC

* Elfeed

   
  #+BEGIN_SRC emacs-lisp  
    (require 'elfeed)

    (setq elfeed-feeds
	  '("http://nullprogram.com/feed/"
	    "http://planet.emacsen.org/atom.xml"
	    "http://reddit.com/r/emacs/.rss"
	    "http://irreal.org/blog/?feed=rss2"))
  #+END_SRC

* Magit
  
  I use magit and magithub to work with github
  
   
  #+BEGIN_SRC emacs-lisp
    (require 'magit)
    (require 'magithub)
    (global-set-key (kbd "C-x g") 'magit-status)
    (magithub-feature-autoinject t)
    (put 'magit-clean 'disabled nil)

    (global-set-key (kbd "<f12>") 'menu-bar-mode)
  #+END_SRC

  This needs github's hub installed.
  
* Images

   
  #+BEGIN_SRC emacs-lisp  
    (require 'image+)
  #+END_SRC

  hydra stuff

   
  #+BEGIN_SRC emacs-lisp  
    (eval-after-load 'image+
      `(when (require 'hydra nil t)
	 (defhydra imagex-sticky-binding (global-map "C-x C-l")
	   "Manipulating Image"
	   ("+" imagex-sticky-zoom-in "zoom in")
	   ("-" imagex-sticky-zoom-out "zoom out")
	   ("M" imagex-sticky-maximize "maximize")
	   ("O" imagex-sticky-restore-original "restore original")
	   ("S" imagex-sticky-save-image "save file")
	   ("r" imagex-sticky-rotate-right "rotate right")
	   ("l" imagex-sticky-rotate-left "rotate left"))))
  #+END_SRC

   
  #+BEGIN_SRC emacs-lisp 
    (imagex-global-sticky-mode 1)
  #+END_SRC

* Study
  
** org-pdfview stuff
   
   #+BEGIN_SRC elisp
     (require 'org-pdfview)
   #+END_SRC

   #+BEGIN_SRC elisp
     (define-key pdf-view-mode-map
       (kbd "C-c C-e") (lambda ()
			 (interactive)
			 (setq link (plist-get (org-pdfview-store-link) :link))
			 (let ((win (get-window-with-predicate
				     (lambda (window)
				       (with-current-buffer (window-buffer window)
					 (eq major-mode 'org-mode))))))

			   (if win
			       (progn
				 (select-window win)
				 (org-insert-link link link))))))
   #+END_SRC

* Key chord

  First require key chord

   
  #+BEGIN_SRC emacs-lisp 
    (require 'key-chord)
    (key-chord-mode +1)
  #+END_SRC
  
  
** Switch to previous buffer

   from bastov's blog

    
   #+BEGIN_SRC emacs-lisp 
     (defun switch-to-previous-buffer ()
       "Switch to previously open buffer.
     Repeated invocations toggle between the two most recently open buffers."
       (interactive)
       (switch-to-buffer (other-buffer (current-buffer) 1)))

     (key-chord-define-global "JJ" 'switch-to-previous-buffer)
   #+END_SRC
  
** Find file

    
   #+BEGIN_SRC emacs-lisp 
     (key-chord-define-global "FF" 'helm-find-files)
   #+END_SRC

** Beginning and end of buffer

    
   #+BEGIN_SRC emacs-lisp
     (key-chord-define-global "jk" 'beginning-of-buffer)
     (key-chord-define-global "JK" 'end-of-buffer)
   #+END_SRC

   
** Ace-jump

   #+BEGIN_SRC emacs-lisp
     (key-chord-define-global "jj" 'ace-jump-mode)
   #+END_SRC
* Other

** Increment and decrements numbers

   Functions to replicate the Vim feature to increment and decrement number at point.

    
   #+BEGIN_SRC emacs-lisp  
     (defun number-at-point (fn)
       (skip-chars-backward "0-9")
       (or (looking-at "[0-9]+")
           (error "No number at point"))
       (replace-match (number-to-string (funcall fn (string-to-number (match-string 0))))))

     (defun increment-number-at-point()
       (interactive)
       (number-at-point '1+))

     (defun decrement-number-at-point()
       (interactive)
       (number-at-point '1-))


     (global-set-key (kbd "C-c +") 'increment-number-at-point)
     (global-set-key (kbd "C-c -") 'decrement-number-at-point)
   #+END_SRC
   
** To "zoom" in and out using mouse

   Sometimes I like to use my mouse for stuff

    
   #+BEGIN_SRC emacs-lisp  
     (global-set-key [C-mouse-4] 'text-scale-increase)
     (global-set-key [C-mouse-5] 'text-scale-decrease)
   #+END_SRC
** Resize window interactively
   Resize windows in speed, I use resize-window it is not position aware, meaning if I'm in the bottom most window it isn't as natural as if resize from the left most window, this happens also in i3wm so I think it's normal, also I don't think it's hard to implement so I would love to see this feature.
   
    
   #+BEGIN_SRC emacs-lisp
     (require 'resize-window)
     (global-set-key (kbd "C-c ;") 'resize-window)
   #+END_SRC

** Winner

   This just returns to the previous window configuration, sadly it doesn't work as excepted when using perspective mode, I hope it gets fixed though

    
   #+BEGIN_SRC emacs-lisp  
     (winner-mode 1)
   #+END_SRC
   
** yas

    
   #+BEGIN_SRC emacs-lisp         
     (yas-global-mode 1)
   #+END_SRC

** expand region
   
   This package is very helpful to navigate code, it's most helpful in languages that use S-expressions which are mainly lisps, but it also works with C and Javascript

    
   #+BEGIN_SRC emacs-lisp  
     (require 'expand-region)
     (global-set-key (kbd "C-c =") 'er/expand-region)
   #+END_SRC

** ace-jump mode

    
   #+BEGIN_SRC emacs-lisp  
     (require 'ace-jump-mode)
     (define-key global-map (kbd "C-c SPC") 'ace-jump-mode)
     (define-key global-map (kbd "C-x SPC") 'ace-jump-mode-pop-mark)
   #+END_SRC

** Recreate scratch buffer

   just recreates scratch buffer when it's killed, I got this from the EmacsWiki

    
   #+BEGIN_SRC emacs-lisp  
     (with-current-buffer "*scratch*"
       (lisp-interaction-mode)
       (make-local-variable 'kill-buffer-query-functions)
       (add-hook 'kill-buffer-query-functions 'kill-scratch-buffer))

     (defun kill-scratch-buffer ()
       ;; The next line is just in case someone calls this manually
       (set-buffer (get-buffer-create "*scratch*"))
       ;; Kill the current (*scratch*) buffer
       (remove-hook 'kill-buffer-query-functions 'kill-scratch-buffer)
       (kill-buffer (current-buffer))
       ;; Make a brand new *scratch* buffer
       (set-buffer (get-buffer-create "*scratch*"))
       (lisp-interaction-mode)
       (make-local-variable 'kill-buffer-query-functions)
       (add-hook 'kill-buffer-query-functions 'kill-scratch-buffer)
       ;; Since we killed it, don't let caller do that.
       nil)
   #+END_SRC

** Backups

   Save backups in another directory

    

   #+BEGIN_SRC emacs-lisp  
     (setq backup-directory-alist '(("." . "~/.emacs.d/backup"))
           backup-by-copying t    ; Don't delink hardlinks
           version-control t      ; Use version numbers on backups
           delete-old-versions t  ; Automatically delete excess backups
           kept-new-versions 20   ; how many of the newest versions to keep
           kept-old-versions 5    ; and how many of the old
           )

   #+END_SRC

** Web browser

   sets my default web browser

    
   #+BEGIN_SRC emacs-lisp  
     (setq browse-url-browser-function 'browse-url-generic
           browse-url-generic-program "icecat")
   #+END_SRC

** Smarter beginning of line
   
   I got this from sacha chua's config which she got from crux package I think 

    
   #+BEGIN_SRC emacs-lisp
     (defun my/smarter-move-beginning-of-line (arg)
       "Move point back to indentation of beginning of line.

     Move point to the first non-whitespace character on this line.
     If point is already there, move to the beginning of the line.
     Effectively toggle between the first non-whitespace character and
     the beginning of the line.

     If ARG is not nil or 1, move forward ARG - 1 lines first.  If
     point reaches the beginning or end of the buffer, stop there."
       (interactive "^p")
       (setq arg (or arg 1))

       ;; Move lines first
       (when (/= arg 1)
         (let ((line-move-visual nil))
           (forward-line (1- arg))))

       (let ((orig-point (point)))
         (back-to-indentation)
         (when (= orig-point (point))
           (move-beginning-of-line 1))))

     ;; remap C-a to `smarter-move-beginning-of-line'
     (global-set-key [remap move-beginning-of-line]
                     'my/smarter-move-beginning-of-line)
   #+END_SRC

   
** Add timestamp

   Adds timestamp before saving each file

    
   #+BEGIN_SRC emacs-lisp  
     (add-hook 'before-save-hook 'time-stamp)
   #+END_SRC

** Tramp sudo edit

   Use tramp to edit files with root, I got this from bbastov blog

    
   #+BEGIN_SRC emacs-lisp  
     (defun sudo-edit (&optional arg)
       "Edit currently visited file as root.
     With a prefix ARG prompt for a file to visit.
     Will also prompt for a file to visit if current
     buffer is not visiting a file."
       (interactive "P")
       (if (or arg (not buffer-file-name))
           (find-file (concat "/sudo:root@localhost:"
                              (ido-read-file-name "Find file(as root): ")))
         (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))
   #+END_SRC

** Company mode

    
   #+BEGIN_SRC emacs-lisp  
     (require 'company)
     (add-hook 'after-init-hook 'global-company-mode)
   #+END_SRC

** Terminal stuff
   Stuff I use when I run Emacs in a terminal emulator

    
   #+BEGIN_SRC emacs-lisp  
     (define-key input-decode-map "\e[1;2A" [S-up])
     (define-key input-decode-map "\e[1;2B" [S-down])
     ;; xclip
     (require 'xclip)
     (xclip-mode 1)
     ;; let the terminal decide the background color
     (custom-set-faces (if (not window-system) '(default ((t (:background "nil"))))))
     ;; to avoid delay in terminal
     (setq-default xterm-query-timeout nil)
   #+END_SRC

   This needs xclip installed on the machine to facilitate copying and pasting between Emacs and other X windows.

** Scratch message

    
   #+BEGIN_SRC emacs-lisp  
     (setq initial-scratch-message ";; ╔═╗┌─┐┬─┐┌─┐┌┬┐┌─┐┬ ┬\n;; ╚═╗│  ├┬┘├─┤ │ │  ├─┤\n;; ╚═╝└─┘┴└─┴ ┴ ┴ └─┘┴ ┴\n\n")
     (setq inhibit-startup-screen t)
   #+END_SRC

** Proced

   auto update proced

    
   #+BEGIN_SRC emacs-lisp  
     (defun proced-settings ()
       (proced-toggle-auto-update 1))
   #+END_SRC

** Hide some minor modes
   
   Hide some minor modes
   
    
   #+BEGIN_SRC emacs-lisp  
     (defvar hidden-minor-modes

       '(flycheck-mode
	 flyspell-mode
	 highlight-parentheses-mode
	 paredit-mode
	 auto-revert-mode
	 which-key-mode
	 abbrev-mode
	 visual-line-mode
	 emmet-mode
	 mmm-mode
	 highlight-indentation-mode
	 elpy-mode
	 dired-async-mode
	 helm-mode))

     (defun purge-minor-modes ()
       (interactive)
       (dolist (x hidden-minor-modes nil)
	 (diminish x)))

     (add-hook 'after-change-major-mode-hook 'purge-minor-modes)
   #+END_SRC

** ace-window
   
   This is like ace-jump but for windows

    
   #+BEGIN_SRC emacs-lisp
     (require 'ace-window)
     (global-set-key (kbd "C-x o") 'ace-window)
   #+END_SRC

   styling the leading char

    
   #+BEGIN_SRC emacs-lisp 
     (set-face-attribute 'aw-leading-char-face nil :height 400)
   #+END_SRC
   
   set scope to frame

    
   #+BEGIN_SRC emacs-lisp  
     (setq aw-scope 'frame)
   #+END_SRC
   
** Flycheck

    
   #+BEGIN_SRC emacs-lisp  
     (require 'flycheck)
     (global-flycheck-mode 1)
   #+END_SRC

** require engine-search

   Some other packages I require

    
   #+BEGIN_SRC emacs-lisp  
     (require 'engine-search)
   #+END_SRC

** Windmove

    
   #+BEGIN_SRC emacs-lisp  
     (global-set-key (kbd "S-<up>") 'windmove-up)
     (global-set-key (kbd "S-<down>") 'windmove-down)
     (global-set-key (kbd "S-<left>") 'windmove-left)
     (global-set-key (kbd "S-<right>") 'windmove-right)
   #+END_SRC

** Startup

    
   #+BEGIN_SRC emacs-lisp  
      (switch-to-buffer "*scratch*")
   #+END_SRC   
** Tea

   Timer code for brewing my tea.

   You need the say program (it comes with GNUstep).

    
   #+BEGIN_SRC emacs-lisp  
     (require 'tea-time)
     (setq tea-time-sound-command "espeak -vde+f5  \"Es ist teezeit mein Kapitän\"")
     (setq tea-time-sound t)
     (define-key global-map "\C-ct" 'tea-time)
   #+END_SRC
** Multi term
   This will toggle and select a dedicated multi term buffer.

    
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-c x") (lambda ()
                                     (interactive)
                                     (require 'multi-term)
                                     (multi-term-dedicated-toggle)
                                     (multi-term-dedicated-select)))
   #+END_SRC

   Add =term-line-mode= and =char-line-mode= keybindings

    
   #+BEGIN_SRC emacs-lisp 
     (eval-after-load 'multi-term
       `(setq term-bind-key-alist
	      (cons '("C-c C-z" . term-stop-subjob)
		    (cons '("C-c C-k" . term-char-mode)
			  (cons '("C-c C-l" . term-line-mode) term-bind-key-alist)))))
   #+END_SRC
** Cursor stuff

    
   #+BEGIN_SRC emacs-lisp
     (blink-cursor-mode t)
     (setq-default cursor-type 'box)
   #+END_SRC
** Flip theme function

   I use a light theme in the morning with colors and all because I work besides my window and it's always sunny where I live so a dark color scheme is not good for my eyes.
   
   In the evening I just use a dark theme like most people do

   
    
   #+BEGIN_SRC emacs-lisp
     (defvar *last-theme* dark-theme
       "The last recorded theme")

     (defun flip-theme ()
       (interactive)
       (if (eq light-theme *last-theme*)
	   (progn
	     (setq *last-theme* dark-theme)
	     (custom-set-faces
	      '(default ((t (:stipple nil :background nil :foreground nil :inverse-video nil :box nil :strike-through nil :overline nil :underline nil :slant normal :weight normal :width normal :family "dina")))))
	     (disable-theme light-theme)
	     (load-theme dark-theme))
	 (progn
	   (disable-theme dark-theme)
	   (custom-set-faces
	      '(default ((t (:stipple nil :background nil :foreground nil :inverse-video nil :box nil :strike-through nil :overline nil :underline nil :slant normal :weight normal :height 113 :width normal :family "DejaVu Sans Mono")))))
	   (setq *last-theme* light-theme)
	   (load-theme light-theme))))
   #+END_SRC
** Paredit stuff
   
    
   #+BEGIN_SRC emacs-lisp 
     (define-key paredit-mode-map (kbd "{") 'paredit-open-curly)
   #+END_SRC
** Hl line mode

    
   #+BEGIN_SRC emacs-lisp 
     (global-hl-line-mode 1)
   #+END_SRC
** Enable pdf-tools
   
   This replaces docview, it has faster rendering capabilities.

   #+BEGIN_SRC emacs-lisp
     (pdf-tools-install)
   #+END_SRC
** Make prompts y or n
   #+BEGIN_SRC emacs-lisp
     (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC
** Setting the executable directory for gtags

   #+BEGIN_SRC emacs-lisp
     (setq ggtags-executable-directory "/usr/bin")
   #+END_SRC
** Display current time
   #+BEGIN_SRC emacs-lisp
     (defun get-current-time ()
       (interactive)
       (message (format-time-string "%l:%M %b %d %a")))
   #+END_SRC
